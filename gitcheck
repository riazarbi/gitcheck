#!/bin/bash

# Check for required system dependencies
if ! command -v yq >/dev/null 2>&1; then
    echo "Error: yq is required but not installed." >&2
    echo "Install from: https://github.com/mikefarah/yq#install" >&2
    exit 1
fi
if ! command -v git >/dev/null 2>&1; then
    echo "Error: git is required but not installed." >&2
    echo "Install from: https://git-scm.com/downloads" >&2
    exit 1
fi
if ! command -v jq >/dev/null 2>&1; then
    echo "Error: jq is required but not installed." >&2
    echo "Install from: https://stedolan.github.io/jq/download/" >&2
    exit 1
fi

# GitCheck - Quality assessment tool for code repositories
# Usage: gitcheck [config_file] [commit_hash] [options]

set -euo pipefail

# =============================================================================
# GLOBAL VARIABLES
# =============================================================================

# Default values
CONFIG_FILE="gitcheck.yaml"
COMMIT_HASH=""
ONLY_PHASE=""
VERBOSE=false
TIMEOUT=300  # 5 minutes default timeout

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# Function to display usage
usage() {
    cat << EOF
Usage: gitcheck [config_file] [commit_hash] [options]

Arguments:
    config_file    Path to gitcheck.yaml file (default: gitcheck.yaml)
    commit_hash    Git commit hash to evaluate (default: latest commit of current branch)

Options:
    --config|-c    Path to gitcheck.yaml file (default: gitcheck.yaml)
    --commit|-C    Git commit hash to evaluate (default: latest commit of current branch)
    --only=PHASE   Run only the specified phase (validate, preflight, checks, metrics)
    --verbose      Print command output to terminal (default: only log to files)
    --timeout=N    Timeout in seconds for long-running commands (default: 300)

Examples:
    gitcheck                                    # Use defaults
    gitcheck my-config.yaml                    # Custom config, latest commit
    gitcheck gitcheck.yaml abc1234             # Specific commit
    gitcheck my-config.yaml HEAD --only=checks # Custom config, HEAD, checks only
    gitcheck --verbose                         # Print output to terminal
EOF
    exit 1
}

# =============================================================================
# ARGUMENT PROCESSING
# =============================================================================

# Process command line arguments
process_arguments() {
    local only_count=0
    while [[ $# -gt 0 ]]; do
        case $1 in
            --config|-c)
                CONFIG_FILE="$2"
                shift 2
                ;;
            --commit|-C)
                COMMIT_HASH="$2"
                shift 2
                ;;
            --only=*)
                ((only_count++))
                if [[ $only_count -gt 1 ]]; then
                    echo "Error: Only one --only flag can be specified"
                    usage
                fi
                ONLY_PHASE="${1#--only=}"
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --timeout=*)
                TIMEOUT="${1#--timeout=}"
                # Validate timeout is a positive integer
                if ! [[ "$TIMEOUT" =~ ^[0-9]+$ ]] || [[ "$TIMEOUT" -eq 0 ]]; then
                    echo "Error: Timeout must be a positive integer"
                    usage
                fi
                shift
                ;;
            --help|-h)
                usage
                ;;
            -*)
                echo "Unknown option: $1"
                usage
                ;;
            *)
                echo "Unknown positional argument: $1"
                usage
                ;;
        esac
    done
}

# Validate argument combinations
validate_arguments() {
    # Validate ONLY_PHASE
    if [[ -n "$ONLY_PHASE" ]]; then
        case "$ONLY_PHASE" in
            validate|preflight|checks|metrics)
                ;;
            *)
                echo "Error: Unknown phase for --only: $ONLY_PHASE"
                usage
                ;;
        esac
    fi

    # If no commit hash specified, use latest commit of current branch
    if [[ -z "$COMMIT_HASH" ]]; then
        COMMIT_HASH=$(git rev-parse HEAD)
    fi

    # Resolve HEAD to actual commit hash if needed
    if [[ "$COMMIT_HASH" == "HEAD" ]]; then
        COMMIT_HASH=$(git rev-parse HEAD)
    fi

    # Validate that the commit hash exists
    if ! git cat-file -e "$COMMIT_HASH^{commit}" 2>/dev/null; then
        echo "Error: Commit hash '$COMMIT_HASH' does not exist or is not a commit."
        exit 1
    fi
}

# Display configuration
display_configuration() {
    echo "GitCheck Configuration:"
    echo "  Config file: $CONFIG_FILE"
    echo "  Commit hash: $COMMIT_HASH"
    echo "  Only phase: $ONLY_PHASE"
    echo "  Verbose: $VERBOSE"
    echo "  Timeout: ${TIMEOUT}s"
    echo ""
}

# =============================================================================
# YAML VALIDATION
# =============================================================================

# Function to validate YAML configuration structure
validate_yaml_config() {
    local yaml_file="$1"
    
    echo "Validating YAML configuration..."
    
    # Check if file is valid YAML
    if ! yq eval '.' "$yaml_file" >/dev/null 2>&1; then
        echo "Error: '$yaml_file' is not a valid YAML file"
        exit 1
    fi
    
    # Determine which sections to validate based on --only flag
    local sections_to_validate=()
    if [[ -z "$ONLY_PHASE" ]]; then
        # If no --only flag, validate all sections
        sections_to_validate=("preflight" "checks" "metrics")
    else
        # Only validate the section for the specified phase
        case "$ONLY_PHASE" in
            preflight) sections_to_validate=("preflight") ;;
            checks) sections_to_validate=("checks") ;;
            metrics) sections_to_validate=("metrics") ;;
            validate) sections_to_validate=("preflight" "checks" "metrics") ;;
        esac
    fi
    
    # Check for required top-level keys (only the ones we're validating)
    for key in "${sections_to_validate[@]}"; do
        if ! yq eval ".$key" "$yaml_file" >/dev/null 2>&1 || [[ "$(yq eval ".$key" "$yaml_file" 2>/dev/null)" == "null" ]]; then
            echo "Error: Missing required key '$key' in configuration"
            exit 1
        fi
    done
    
    # Validate sections based on what we're running
    for section in "${sections_to_validate[@]}"; do
        case "$section" in
            preflight)
                local preflight_count=$(yq eval '.preflight | length' "$yaml_file" 2>/dev/null || echo "0")
                if [[ "$preflight_count" -eq 0 ]]; then
                    echo "Warning: No preflight commands found"
                else
                    for i in $(seq 0 $((preflight_count - 1))); do
                        local name_exists=$(yq eval ".preflight[$i].name" "$yaml_file" 2>/dev/null)
                        local command_exists=$(yq eval ".preflight[$i].command" "$yaml_file" 2>/dev/null)
                        
                        if [[ "$name_exists" == "null" ]] || [[ -z "$name_exists" ]]; then
                            echo "Error: Preflight command $((i+1)) missing 'name' field"
                            exit 1
                        fi
                        if [[ "$command_exists" == "null" ]] || [[ -z "$command_exists" ]]; then
                            echo "Error: Preflight command $((i+1)) missing 'command' field"
                            exit 1
                        fi
                    done
                fi
                ;;
            checks)
                local checks_count=$(yq eval '.checks | length' "$yaml_file" 2>/dev/null || echo "0")
                if [[ "$checks_count" -eq 0 ]]; then
                    echo "Warning: No checks commands found"
                else
                    for i in $(seq 0 $((checks_count - 1))); do
                        local name_exists=$(yq eval ".checks[$i].name" "$yaml_file" 2>/dev/null)
                        local command_exists=$(yq eval ".checks[$i].command" "$yaml_file" 2>/dev/null)
                        
                        if [[ "$name_exists" == "null" ]] || [[ -z "$name_exists" ]]; then
                            echo "Error: Checks command $((i+1)) missing 'name' field"
                            exit 1
                        fi
                        if [[ "$command_exists" == "null" ]] || [[ -z "$command_exists" ]]; then
                            echo "Error: Checks command $((i+1)) missing 'command' field"
                            exit 1
                        fi
                    done
                fi
                ;;
            metrics)
                local metrics_count=$(yq eval '.metrics | length' "$yaml_file" 2>/dev/null || echo "0")
                if [[ "$metrics_count" -eq 0 ]]; then
                    echo "Warning: No metrics commands found"
                else
                    for i in $(seq 0 $((metrics_count - 1))); do
                        local name_exists=$(yq eval ".metrics[$i].name" "$yaml_file" 2>/dev/null)
                        local command_exists=$(yq eval ".metrics[$i].command" "$yaml_file" 2>/dev/null)
                        local allowed_values_exists=$(yq eval ".metrics[$i].allowed_values" "$yaml_file" 2>/dev/null)
                        local data_type_exists=$(yq eval ".metrics[$i].data_type" "$yaml_file" 2>/dev/null)
                        local default_exists=$(yq eval ".metrics[$i].default" "$yaml_file" 2>/dev/null)
                        local allowed_values_json=$(yq eval -o=json ".metrics[$i].allowed_values" "$yaml_file" 2>/dev/null)
                        local data_type=$(yq eval ".metrics[$i].data_type" "$yaml_file" 2>/dev/null)
                        local default_value=$(yq eval ".metrics[$i].default" "$yaml_file" 2>/dev/null)
                        
                        if [[ "$name_exists" == "null" ]] || [[ -z "$name_exists" ]]; then
                            echo "Error: Metrics command $((i+1)) missing 'name' field"
                            exit 1
                        fi
                        if [[ "$command_exists" == "null" ]] || [[ -z "$command_exists" ]]; then
                            echo "Error: Metrics command $((i+1)) missing 'command' field"
                            exit 1
                        fi
                        if [[ "$allowed_values_exists" == "null" ]] || [[ -z "$allowed_values_exists" ]]; then
                            echo "Error: Metrics command $((i+1)) missing 'allowed_values' field"
                            exit 1
                        fi
                        if [[ "$data_type_exists" == "null" ]] || [[ -z "$data_type_exists" ]]; then
                            echo "Error: Metrics command $((i+1)) missing 'data_type' field"
                            exit 1
                        fi
                        if [[ "$default_exists" == "null" ]] || [[ -z "$default_exists" ]]; then
                            echo "Error: Metrics command $((i+1)) missing 'default' field"
                            exit 1
                        fi
                        # Validate default is in allowed range/set
                        local default_valid=0
                        if [[ "$data_type" == "number" ]]; then
                            # Check if default is in any allowed range or matches an allowed value
                            for allowed_val in $(echo "$allowed_values_json" | jq -r '.[]'); do
                                if [[ "$allowed_val" =~ ^([0-9]+(\.[0-9]+)?)-([0-9]+(\.[0-9]+)?)$ ]]; then
                                    local range_min="${BASH_REMATCH[1]}"
                                    local range_max="${BASH_REMATCH[3]}"
                                    if (( $(echo "$default_value >= $range_min && $default_value <= $range_max" | bc -l) )); then
                                        default_valid=1
                                        break
                                    fi
                                elif [[ "$allowed_val" == "$default_value" ]]; then
                                    default_valid=1
                                    break
                                fi
                            done
                        else
                            # For string, must be in allowed_values set
                            if jq -e --arg val "$default_value" '. | index($val)' <<< "$allowed_values_json" >/dev/null; then
                                default_valid=1
                            fi
                        fi
                        if [[ $default_valid -ne 1 ]]; then
                            echo "Error: Metrics command $((i+1)) has a default value ('$default_value') not in allowed_values."
                            exit 1
                        fi
                    done
                fi
                ;;
        esac
    done
    
    echo "✅ YAML configuration validation passed"
    echo ""
}

# =============================================================================
# YAML PARSING AND EXECUTION
# =============================================================================



# Function to execute commands from a section
execute_yaml_section() {
    # Temporarily disable set -e to allow command failures without exiting
    set +e
    
    local yaml_file="$1"
    local section="$2"
    local phase_name="$3"

    echo "Running $phase_name phase..."
    echo "=================================="

    local success_count=0
    local total_count=0



    # Simple approach: use yq to get command count and iterate directly
    local command_count
    command_count=$(yq eval ".$section | length" "$yaml_file")
    
    # Parse all section data once to avoid redundant yq calls
    local section_data
    section_data=$(yq eval -o=json ".$section" "$yaml_file")
    
    for ((i=0; i<command_count; i++)); do
        local name command
        name=$(echo "$section_data" | jq -r ".[$i].name")
        command=$(echo "$section_data" | jq -r ".[$i].command")
        
        ((total_count++))
        echo "Running: $name"
        if [[ "$VERBOSE" == "true" ]]; then
            echo "Command: $command"
        fi
        local artefact_file="$ARTEFACT_DIR/$name"
        echo "Saving output to: $artefact_file"
        (
            set +e
            # Write header to artefact file
            {
                echo "# GitCheck Artefact: $name"
                echo "# Generated: $(date)"
                echo "# Command: $command"
                echo "# Phase: $phase_name"
                echo "# ========================================="
                echo ""
            } > "$artefact_file"
            # Run the command with timeout, conditionally printing to terminal based on verbose flag
            if [[ "$VERBOSE" == "true" ]]; then
                timeout "$TIMEOUT" bash -c "$command" 2>&1 | tee -a "$artefact_file"
            else
                timeout "$TIMEOUT" bash -c "$command" 2>&1 >> "$artefact_file"
            fi
            exit_status=${PIPESTATUS[0]}
            # Handle timeout exit code (124)
            if [[ $exit_status -eq 124 ]]; then
                echo "TIMEOUT: Command exceeded ${TIMEOUT}s timeout" >> "$artefact_file"
                exit 124
            fi
            exit $exit_status
        )
        local exit_status=$?
        # For checks phase, treat any exit code as success (command executed)
        # The non-zero exit codes indicate issues found, not execution failure
        if [[ "$section" == "checks" ]]; then
            if [[ $exit_status -eq 124 ]]; then
                echo "⏰ $name: TIMEOUT (exceeded ${TIMEOUT}s)"
            else
                echo "✅ $name: EXECUTED (exit code: $exit_status)"
            fi
            ((success_count++))
        else
            # For other phases (preflight), treat non-zero as failure
            if [[ $exit_status -eq 0 ]]; then
                echo "✅ $name: SUCCESS"
                ((success_count++))
            elif [[ $exit_status -eq 124 ]]; then
                echo "⏰ $name: TIMEOUT (exceeded ${TIMEOUT}s)"
            else
                echo "❌ $name: FAILED (exit code: $exit_status)"
            fi
        fi
        echo ""
    done
    echo ""
    
    # Re-enable set -e
    set -e
    
    # Only exit with failure if any commands failed to execute
    # (not if they ran successfully but found issues)
    if [[ $success_count -lt $total_count ]]; then
        echo "$phase_name phase completed: $success_count/$total_count commands succeeded"
        return 1
    else
        echo "$phase_name phase completed: $success_count/$total_count commands succeeded"
        return 0
    fi
}



# Function to execute metrics phase
execute_metrics_phase() {
    set +e
    local yaml_file="$1"
    local phase_name="Metrics"
    local metrics_dir="$ARTEFACT_DIR/metrics"
    mkdir -p "$metrics_dir"
    local results_json="[]"
    local fail_count=0
    local total_count=0

    echo "Running $phase_name phase..."
    echo "=================================="

    local metrics_count
    metrics_count=$(yq eval ".metrics | length" "$yaml_file")
    
    # Parse all metrics data once to avoid redundant yq calls
    local metrics_data
    metrics_data=$(yq eval -o=json ".metrics" "$yaml_file")
    
    for ((i=0; i<metrics_count; i++)); do
        local name command allowed_values data_type default_value
        name=$(echo "$metrics_data" | jq -r ".[$i].name")
        command=$(echo "$metrics_data" | jq -r ".[$i].command")
        allowed_values=$(echo "$metrics_data" | jq -c ".[$i].allowed_values")
        data_type=$(echo "$metrics_data" | jq -r ".[$i].data_type")
        default_value=$(echo "$metrics_data" | jq -r ".[$i].default")
        ((total_count++))
        echo "Running metric: $name"
        if [[ "$VERBOSE" == "true" ]]; then
            echo "Command: $command"
        fi
        local artefact_file="$metrics_dir/$name"
        echo "Saving output to: $artefact_file"
        local tmp_output_file
        tmp_output_file=$(mktemp)
        (
            set +e
            # Write header to artefact file
            {
                echo "# GitCheck Metric Artefact: $name"
                echo "# Generated: $(date)"
                echo "# Command: $command"
                echo "# Allowed values: $allowed_values"
                echo "# Phase: $phase_name"
                echo "# ========================================="
                echo ""
            } > "$artefact_file"
            # Run the command with timeout, capture output (stdout only, trimmed)
            metric_output=$(timeout "$TIMEOUT" bash -c "$command" 2>&1)
            metric_status=${PIPESTATUS[0]}
            # Handle timeout exit code (124)
            if [[ $metric_status -eq 124 ]]; then
                echo "TIMEOUT: Command exceeded ${TIMEOUT}s timeout" >> "$artefact_file"
                metric_output="TIMEOUT"
            fi
            # Conditionally print to terminal based on verbose flag
            if [[ "$VERBOSE" == "true" ]]; then
                echo "$metric_output" | tee -a "$artefact_file"
            else
                echo "$metric_output" >> "$artefact_file"
            fi
            # Only use first line of output for value comparison
            echo "$metric_output" | head -n1 | xargs > "$tmp_output_file"
            exit $metric_status
        )
        local exit_status=$?
        local metric_value=""
        local metric_status_str="fail"
        if [[ -f "$tmp_output_file" ]]; then
            metric_value=$(cat "$tmp_output_file")
            rm -f "$tmp_output_file"
        fi
        # Compare output to allowed_values based on data_type
        local pass=0
        if [[ $exit_status -eq 0 ]]; then
            if [[ "$data_type" == "number" ]]; then
                # For numeric values, check ranges
                while IFS= read -r allowed_val; do
                    if [[ "$allowed_val" =~ ^([0-9]+(\.[0-9]+)?)-([0-9]+(\.[0-9]+)?)$ ]]; then
                        local range_min="${BASH_REMATCH[1]}"
                        local range_max="${BASH_REMATCH[3]}"
                        # Check if metric_value is within this range (using bc for decimal comparison)
                        if (( $(echo "$metric_value >= $range_min && $metric_value <= $range_max" | bc -l) )); then
                            pass=1
                            break
                        fi
                    elif [[ "$allowed_val" == "$metric_value" ]]; then
                        # Exact match for non-range values
                        pass=1
                        break
                    fi
                done < <(jq -r '.[]' <<< "$allowed_values")
            else
                # For string values, use exact set matching
                if jq -e --arg val "$metric_value" '. | index($val)' <<< "$allowed_values" >/dev/null; then
                    pass=1
                fi
            fi
            
            if [[ $pass -eq 1 ]]; then
                echo "✅ $name: PASS (value: $metric_value)"
                metric_status_str="pass"
            else
                echo "❌ $name: FAIL (value: $metric_value, allowed: $allowed_values)"
                metric_value="$default_value"
                metric_status_str="default"
                ((fail_count++))
            fi
        elif [[ $exit_status -eq 124 ]]; then
            echo "⏰ $name: TIMEOUT (exceeded ${TIMEOUT}s)"
            metric_value="$default_value"
            metric_status_str="default"
            ((fail_count++))
        else
            echo "❌ $name: ERROR (command failed, exit code: $exit_status)"
            metric_value="$default_value"
            metric_status_str="default"
            ((fail_count++))
        fi
        # Save result to results_json
        results_json=$(jq -c --arg name "$name" --arg value "$metric_value" --argjson allowed "$allowed_values" --arg status "$metric_status_str" '. += [{name: $name, value: $value, allowed_values: $allowed, status: $status}]' <<< "$results_json")
        echo ""
    done

    # Always write metrics.json, even if some metrics fail
    echo "$results_json" | jq '.' > "$ARTEFACT_DIR/metrics.json"
    echo "Metrics phase completed: $((total_count - fail_count))/$total_count metrics passed"
    echo "Results saved to $ARTEFACT_DIR/metrics.json"
    set -e
    if [[ $fail_count -gt 0 ]]; then
        return 1
    else
        return 0
    fi
}

# MAIN EXECUTION
process_arguments "$@"
validate_arguments
display_configuration 

# Validate YAML configuration
validate_yaml_config "$CONFIG_FILE"

# Ensure artefact folder exists
ARTEFACT_DIR=".gitcheck"
mkdir -p "$ARTEFACT_DIR"

# If --only is set, run only that phase
if [[ "$ONLY_PHASE" == "validate" ]]; then
    echo "Configuration validated successfully."
    exit 0
elif [[ "$ONLY_PHASE" == "preflight" ]]; then
    execute_yaml_section "$CONFIG_FILE" "preflight" "Preflight"
    echo "GitCheck completed!"
    exit 0
elif [[ "$ONLY_PHASE" == "checks" ]]; then
    execute_yaml_section "$CONFIG_FILE" "checks" "Checks"
    echo "GitCheck completed!"
    exit 0
elif [[ "$ONLY_PHASE" == "metrics" ]]; then
    execute_metrics_phase "$CONFIG_FILE"
    echo "GitCheck completed!"
    exit $?
else
    # No --only flag: run all phases in order
    execute_yaml_section "$CONFIG_FILE" "preflight" "Preflight"
    execute_yaml_section "$CONFIG_FILE" "checks" "Checks"
    execute_metrics_phase "$CONFIG_FILE"
    echo "GitCheck completed!"
    exit $?
fi 