#!/bin/bash

# Check for required system dependencies
if ! command -v yq >/dev/null 2>&1; then
    echo "Error: yq is required but not installed." >&2
    echo "Install from: https://github.com/mikefarah/yq#install" >&2
    exit 1
fi
if ! command -v git >/dev/null 2>&1; then
    echo "Error: git is required but not installed." >&2
    echo "Install from: https://git-scm.com/downloads" >&2
    exit 1
fi

# GitCheck - Quality assessment tool for code repositories
# Usage: gitcheck [config_file] [commit_hash] [options]

set -euo pipefail

# =============================================================================
# GLOBAL VARIABLES
# =============================================================================

# Default values
CONFIG_FILE="gitcheck.yaml"
COMMIT_HASH=""
ONLY_PHASE=""

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# Function to display usage
usage() {
    cat << EOF
Usage: gitcheck [config_file] [commit_hash] [options]

Arguments:
    config_file    Path to gitcheck.yaml file (default: gitcheck.yaml)
    commit_hash    Git commit hash to evaluate (default: latest commit of current branch)

Options:
    --config|-c    Path to gitcheck.yaml file (default: gitcheck.yaml)
    --commit|-C    Git commit hash to evaluate (default: latest commit of current branch)
    --only=PHASE   Run only the specified phase (validate, preflight, checks, metrics)

Examples:
    gitcheck                                    # Use defaults
    gitcheck my-config.yaml                    # Custom config, latest commit
    gitcheck gitcheck.yaml abc1234             # Specific commit
    gitcheck my-config.yaml HEAD --only=checks # Custom config, HEAD, checks only
EOF
    exit 1
}

# =============================================================================
# ARGUMENT PROCESSING
# =============================================================================

# Process command line arguments
process_arguments() {
    local only_count=0
    while [[ $# -gt 0 ]]; do
        case $1 in
            --config|-c)
                CONFIG_FILE="$2"
                shift 2
                ;;
            --commit|-C)
                COMMIT_HASH="$2"
                shift 2
                ;;
            --only=*)
                ((only_count++))
                if [[ $only_count -gt 1 ]]; then
                    echo "Error: Only one --only flag can be specified"
                    usage
                fi
                ONLY_PHASE="${1#--only=}"
                shift
                ;;
            --help|-h)
                usage
                ;;
            -*)
                echo "Unknown option: $1"
                usage
                ;;
            *)
                echo "Unknown positional argument: $1"
                usage
                ;;
        esac
    done
}

# Validate argument combinations
validate_arguments() {
    # Validate ONLY_PHASE
    if [[ -n "$ONLY_PHASE" ]]; then
        case "$ONLY_PHASE" in
            validate|preflight|checks|metrics)
                ;;
            *)
                echo "Error: Unknown phase for --only: $ONLY_PHASE"
                usage
                ;;
        esac
    fi

    # If no commit hash specified, use latest commit of current branch
    if [[ -z "$COMMIT_HASH" ]]; then
        COMMIT_HASH=$(git rev-parse HEAD)
    fi

    # Resolve HEAD to actual commit hash if needed
    if [[ "$COMMIT_HASH" == "HEAD" ]]; then
        COMMIT_HASH=$(git rev-parse HEAD)
    fi

    # Validate that the commit hash exists
    if ! git cat-file -e "$COMMIT_HASH^{commit}" 2>/dev/null; then
        echo "Error: Commit hash '$COMMIT_HASH' does not exist or is not a commit."
        exit 1
    fi
}

# Display configuration
display_configuration() {
    echo "GitCheck Configuration:"
    echo "  Config file: $CONFIG_FILE"
    echo "  Commit hash: $COMMIT_HASH"
    echo "  Only phase: $ONLY_PHASE"
    echo ""
}

# =============================================================================
# YAML VALIDATION
# =============================================================================

# Function to validate YAML configuration structure
validate_yaml_config() {
    local yaml_file="$1"
    
    echo "Validating YAML configuration..."
    
    # Check if file is valid YAML
    if ! yq eval '.' "$yaml_file" >/dev/null 2>&1; then
        echo "Error: '$yaml_file' is not a valid YAML file"
        exit 1
    fi
    
    # Check for required top-level keys
    local required_keys=("preflight" "checks" "metrics")
    for key in "${required_keys[@]}"; do
        if ! yq eval ".$key" "$yaml_file" >/dev/null 2>&1 || [[ "$(yq eval ".$key" "$yaml_file" 2>/dev/null)" == "null" ]]; then
            echo "Error: Missing required key '$key' in configuration"
            exit 1
        fi
    done
    
    # Validate preflight section structure
    local preflight_count=$(yq eval '.preflight | length' "$yaml_file" 2>/dev/null || echo "0")
    if [[ "$preflight_count" -eq 0 ]]; then
        echo "Warning: No preflight commands found"
    else
        for i in $(seq 0 $((preflight_count - 1))); do
            local name_exists=$(yq eval ".preflight[$i].name" "$yaml_file" 2>/dev/null)
            local command_exists=$(yq eval ".preflight[$i].command" "$yaml_file" 2>/dev/null)
            
            if [[ "$name_exists" == "null" ]] || [[ -z "$name_exists" ]]; then
                echo "Error: Preflight command $((i+1)) missing 'name' field"
                exit 1
            fi
            if [[ "$command_exists" == "null" ]] || [[ -z "$command_exists" ]]; then
                echo "Error: Preflight command $((i+1)) missing 'command' field"
                exit 1
            fi
        done
    fi
    
    # Validate checks section structure
    local checks_count=$(yq eval '.checks | length' "$yaml_file" 2>/dev/null || echo "0")
    if [[ "$checks_count" -eq 0 ]]; then
        echo "Warning: No checks commands found"
    else
        for i in $(seq 0 $((checks_count - 1))); do
            local name_exists=$(yq eval ".checks[$i].name" "$yaml_file" 2>/dev/null)
            local command_exists=$(yq eval ".checks[$i].command" "$yaml_file" 2>/dev/null)
            
            if [[ "$name_exists" == "null" ]] || [[ -z "$name_exists" ]]; then
                echo "Error: Checks command $((i+1)) missing 'name' field"
                exit 1
            fi
            if [[ "$command_exists" == "null" ]] || [[ -z "$command_exists" ]]; then
                echo "Error: Checks command $((i+1)) missing 'command' field"
                exit 1
            fi
        done
    fi
    
    # Validate metrics section structure
    local metrics_count=$(yq eval '.metrics | length' "$yaml_file" 2>/dev/null || echo "0")
    if [[ "$metrics_count" -eq 0 ]]; then
        echo "Warning: No metrics commands found"
    else
        for i in $(seq 0 $((metrics_count - 1))); do
            local name_exists=$(yq eval ".metrics[$i].name" "$yaml_file" 2>/dev/null)
            local command_exists=$(yq eval ".metrics[$i].command" "$yaml_file" 2>/dev/null)
            local allowed_values_exists=$(yq eval ".metrics[$i].allowed_values" "$yaml_file" 2>/dev/null)
            
            if [[ "$name_exists" == "null" ]] || [[ -z "$name_exists" ]]; then
                echo "Error: Metrics command $((i+1)) missing 'name' field"
                exit 1
            fi
            if [[ "$command_exists" == "null" ]] || [[ -z "$command_exists" ]]; then
                echo "Error: Metrics command $((i+1)) missing 'command' field"
                exit 1
            fi
            if [[ "$allowed_values_exists" == "null" ]] || [[ -z "$allowed_values_exists" ]]; then
                echo "Error: Metrics command $((i+1)) missing 'allowed_values' field"
                exit 1
            fi
        done
    fi
    
    echo "✅ YAML configuration validation passed"
    echo ""
}

# =============================================================================
# YAML PARSING AND EXECUTION
# =============================================================================

# Function to parse YAML file and extract commands from a section
parse_yaml_section() {
    local yaml_file="$1"
    local section="$2"
    
    if [[ ! -f "$yaml_file" ]]; then
        echo "Error: Config file '$yaml_file' not found"
        exit 1
    fi
    
    local in_section=false
    local commands=()
    
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        
        # Check if we're entering the target section
        if [[ "$line" =~ ^[[:space:]]*${section}: ]]; then
            in_section=true
            continue
        fi
        
        # Check if we're leaving the section (next top-level key)
        if [[ "$in_section" == true ]] && [[ "$line" =~ ^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_]*: ]] && [[ ! "$line" =~ ^[[:space:]]*${section}: ]]; then
            break
        fi
        
        # Extract command if we're in the right section
        if [[ "$in_section" == true ]] && [[ "$line" =~ ^[[:space:]]*-[[:space:]]*name:[[:space:]]*\"([^\"]+)\" ]]; then
            local name="${BASH_REMATCH[1]}"
            # Read next line for command
            if IFS= read -r next_line; then
                if [[ "$next_line" =~ ^[[:space:]]*command:[[:space:]]*\"([^\"]+)\" ]]; then
                    local command="${BASH_REMATCH[1]}"
                    commands+=("$name:$command")
                fi
            fi
        fi
    done < "$yaml_file"
    
    printf '%s\n' "${commands[@]}"
}

# Function to execute commands from a section
execute_yaml_section() {
    local yaml_file="$1"
    local section="$2"
    local phase_name="$3"
    
    echo "Running $phase_name phase..."
    echo "=================================="
    
    local commands=()
    while IFS= read -r line; do
        commands+=("$line")
    done < <(parse_yaml_section "$yaml_file" "$section")
    
    if [[ ${#commands[@]} -eq 0 ]]; then
        echo "No commands found in $section section"
        return 0
    fi
    
    local success_count=0
    local total_count=${#commands[@]}
    
    for cmd_pair in "${commands[@]}"; do
        IFS=':' read -r name command <<< "$cmd_pair"
        echo "Running: $name"
        echo "Command: $command"
        
        if eval "$command"; then
            echo "✅ $name: SUCCESS"
            ((success_count++))
        else
            echo "❌ $name: FAILED"
        fi
        echo ""
    done
    
    echo "$phase_name phase completed: $success_count/$total_count commands succeeded"
    echo ""
    
    return $((total_count - success_count))
}

# MAIN EXECUTION
process_arguments "$@"
validate_arguments
display_configuration 

# Validate YAML configuration
validate_yaml_config "$CONFIG_FILE"

# Ensure artefact folder exists
ARTEFACT_DIR=".gitcheck"
mkdir -p "$ARTEFACT_DIR"

# If --only is set, run only that phase
if [[ "$ONLY_PHASE" == "validate" ]]; then
    echo "Configuration validated successfully."
    exit 0
elif [[ "$ONLY_PHASE" == "preflight" ]]; then
    execute_yaml_section "$CONFIG_FILE" "preflight" "Preflight"
    echo "GitCheck completed!"
    exit 0
elif [[ "$ONLY_PHASE" == "checks" ]]; then
    execute_yaml_section "$CONFIG_FILE" "checks" "Checks"
    echo "GitCheck completed!"
    exit 0
elif [[ "$ONLY_PHASE" == "metrics" ]]; then
    echo "Metrics phase not yet implemented"
    exit 1
else
    # No --only flag: run all phases in order
    execute_yaml_section "$CONFIG_FILE" "preflight" "Preflight"
    execute_yaml_section "$CONFIG_FILE" "checks" "Checks"
    echo "Metrics phase not yet implemented"
    echo "GitCheck completed!"
fi 