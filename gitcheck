#!/bin/bash

# Check for required system dependencies
if ! command -v yq >/dev/null 2>&1; then
    echo "Error: yq is required but not installed." >&2
    echo "Install from: https://github.com/mikefarah/yq#install" >&2
    exit 1
fi
if ! command -v git >/dev/null 2>&1; then
    echo "Error: git is required but not installed." >&2
    echo "Install from: https://git-scm.com/downloads" >&2
    exit 1
fi
if ! command -v jq >/dev/null 2>&1; then
    echo "Error: jq is required but not installed." >&2
    echo "Install from: https://stedolan.github.io/jq/download/" >&2
    exit 1
fi

# GitCheck - Quality assessment tool for code repositories
# Usage: gitcheck [config_file] [commit_hash] [options]

set -euo pipefail

# =============================================================================
# GLOBAL VARIABLES
# =============================================================================

# Default values
CONFIG_FILE="gitcheck.yaml"
COMMIT_HASH=""
ONLY_PHASE=""

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# Function to display usage
usage() {
    cat << EOF
Usage: gitcheck [config_file] [commit_hash] [options]

Arguments:
    config_file    Path to gitcheck.yaml file (default: gitcheck.yaml)
    commit_hash    Git commit hash to evaluate (default: latest commit of current branch)

Options:
    --config|-c    Path to gitcheck.yaml file (default: gitcheck.yaml)
    --commit|-C    Git commit hash to evaluate (default: latest commit of current branch)
    --only=PHASE   Run only the specified phase (validate, preflight, checks, metrics)

Examples:
    gitcheck                                    # Use defaults
    gitcheck my-config.yaml                    # Custom config, latest commit
    gitcheck gitcheck.yaml abc1234             # Specific commit
    gitcheck my-config.yaml HEAD --only=checks # Custom config, HEAD, checks only
EOF
    exit 1
}

# =============================================================================
# ARGUMENT PROCESSING
# =============================================================================

# Process command line arguments
process_arguments() {
    local only_count=0
    while [[ $# -gt 0 ]]; do
        case $1 in
            --config|-c)
                CONFIG_FILE="$2"
                shift 2
                ;;
            --commit|-C)
                COMMIT_HASH="$2"
                shift 2
                ;;
            --only=*)
                ((only_count++))
                if [[ $only_count -gt 1 ]]; then
                    echo "Error: Only one --only flag can be specified"
                    usage
                fi
                ONLY_PHASE="${1#--only=}"
                shift
                ;;
            --help|-h)
                usage
                ;;
            -*)
                echo "Unknown option: $1"
                usage
                ;;
            *)
                echo "Unknown positional argument: $1"
                usage
                ;;
        esac
    done
}

# Validate argument combinations
validate_arguments() {
    # Validate ONLY_PHASE
    if [[ -n "$ONLY_PHASE" ]]; then
        case "$ONLY_PHASE" in
            validate|preflight|checks|metrics)
                ;;
            *)
                echo "Error: Unknown phase for --only: $ONLY_PHASE"
                usage
                ;;
        esac
    fi

    # If no commit hash specified, use latest commit of current branch
    if [[ -z "$COMMIT_HASH" ]]; then
        COMMIT_HASH=$(git rev-parse HEAD)
    fi

    # Resolve HEAD to actual commit hash if needed
    if [[ "$COMMIT_HASH" == "HEAD" ]]; then
        COMMIT_HASH=$(git rev-parse HEAD)
    fi

    # Validate that the commit hash exists
    if ! git cat-file -e "$COMMIT_HASH^{commit}" 2>/dev/null; then
        echo "Error: Commit hash '$COMMIT_HASH' does not exist or is not a commit."
        exit 1
    fi
}

# Display configuration
display_configuration() {
    echo "GitCheck Configuration:"
    echo "  Config file: $CONFIG_FILE"
    echo "  Commit hash: $COMMIT_HASH"
    echo "  Only phase: $ONLY_PHASE"
    echo ""
}

# =============================================================================
# YAML VALIDATION
# =============================================================================

# Function to validate YAML configuration structure
validate_yaml_config() {
    local yaml_file="$1"
    
    echo "Validating YAML configuration..."
    
    # Check if file is valid YAML
    if ! yq eval '.' "$yaml_file" >/dev/null 2>&1; then
        echo "Error: '$yaml_file' is not a valid YAML file"
        exit 1
    fi
    
    # Check for required top-level keys
    local required_keys=("preflight" "checks" "metrics")
    for key in "${required_keys[@]}"; do
        if ! yq eval ".$key" "$yaml_file" >/dev/null 2>&1 || [[ "$(yq eval ".$key" "$yaml_file" 2>/dev/null)" == "null" ]]; then
            echo "Error: Missing required key '$key' in configuration"
            exit 1
        fi
    done
    
    # Validate preflight section structure
    local preflight_count=$(yq eval '.preflight | length' "$yaml_file" 2>/dev/null || echo "0")
    if [[ "$preflight_count" -eq 0 ]]; then
        echo "Warning: No preflight commands found"
    else
        for i in $(seq 0 $((preflight_count - 1))); do
            local name_exists=$(yq eval ".preflight[$i].name" "$yaml_file" 2>/dev/null)
            local command_exists=$(yq eval ".preflight[$i].command" "$yaml_file" 2>/dev/null)
            
            if [[ "$name_exists" == "null" ]] || [[ -z "$name_exists" ]]; then
                echo "Error: Preflight command $((i+1)) missing 'name' field"
                exit 1
            fi
            if [[ "$command_exists" == "null" ]] || [[ -z "$command_exists" ]]; then
                echo "Error: Preflight command $((i+1)) missing 'command' field"
                exit 1
            fi
        done
    fi
    
    # Validate checks section structure
    local checks_count=$(yq eval '.checks | length' "$yaml_file" 2>/dev/null || echo "0")
    if [[ "$checks_count" -eq 0 ]]; then
        echo "Warning: No checks commands found"
    else
        for i in $(seq 0 $((checks_count - 1))); do
            local name_exists=$(yq eval ".checks[$i].name" "$yaml_file" 2>/dev/null)
            local command_exists=$(yq eval ".checks[$i].command" "$yaml_file" 2>/dev/null)
            
            if [[ "$name_exists" == "null" ]] || [[ -z "$name_exists" ]]; then
                echo "Error: Checks command $((i+1)) missing 'name' field"
                exit 1
            fi
            if [[ "$command_exists" == "null" ]] || [[ -z "$command_exists" ]]; then
                echo "Error: Checks command $((i+1)) missing 'command' field"
                exit 1
            fi
        done
    fi
    
    # Validate metrics section structure
    local metrics_count=$(yq eval '.metrics | length' "$yaml_file" 2>/dev/null || echo "0")
    if [[ "$metrics_count" -eq 0 ]]; then
        echo "Warning: No metrics commands found"
    else
        for i in $(seq 0 $((metrics_count - 1))); do
            local name_exists=$(yq eval ".metrics[$i].name" "$yaml_file" 2>/dev/null)
            local command_exists=$(yq eval ".metrics[$i].command" "$yaml_file" 2>/dev/null)
            local allowed_values_exists=$(yq eval ".metrics[$i].allowed_values" "$yaml_file" 2>/dev/null)
            
            if [[ "$name_exists" == "null" ]] || [[ -z "$name_exists" ]]; then
                echo "Error: Metrics command $((i+1)) missing 'name' field"
                exit 1
            fi
            if [[ "$command_exists" == "null" ]] || [[ -z "$command_exists" ]]; then
                echo "Error: Metrics command $((i+1)) missing 'command' field"
                exit 1
            fi
            if [[ "$allowed_values_exists" == "null" ]] || [[ -z "$allowed_values_exists" ]]; then
                echo "Error: Metrics command $((i+1)) missing 'allowed_values' field"
                exit 1
            fi
        done
    fi
    
    echo "✅ YAML configuration validation passed"
    echo ""
}

# =============================================================================
# YAML PARSING AND EXECUTION
# =============================================================================

# Function to parse YAML file and extract commands from a section
parse_yaml_section() {
    local yaml_file="$1"
    local section="$2"
    if [[ ! -f "$yaml_file" ]]; then
        echo "Error: Config file '$yaml_file' not found"
        exit 1
    fi
    yq -o=json eval ".$section" "$yaml_file"
}

# Function to execute commands from a section
execute_yaml_section() {
    # Temporarily disable set -e to allow command failures without exiting
    set +e
    
    local yaml_file="$1"
    local section="$2"
    local phase_name="$3"

    echo "Running $phase_name phase..."
    echo "=================================="

    local success_count=0
    local total_count=0

    # Remove debug output
    # (No debug echo statements)

    while IFS= read -r obj; do
        local name command
        name=$(jq -r '.name' <<< "$obj")
        command=$(jq -r '.command' <<< "$obj")
        ((total_count++))
        echo "Running: $name"
        echo "Command: $command"
        local artefact_file="$ARTEFACT_DIR/$name"
        echo "Saving output to: $artefact_file"
        (
            set +e
            {
                echo "# GitCheck Artefact: $name"
                echo "# Generated: $(date)"
                echo "# Command: $command"
                echo "# Phase: $phase_name"
                echo "# ========================================="
                echo ""
            } | tee "$artefact_file"
            # Now run the command, teeing both stdout and stderr to the artefact file and terminal
            eval "$command" 2>&1 | tee -a "$artefact_file"
            exit_status=${PIPESTATUS[0]}
            exit $exit_status
        )
        local exit_status=$?
        # For checks phase, treat any exit code as success (command executed)
        # The non-zero exit codes indicate issues found, not execution failure
        if [[ "$section" == "checks" ]]; then
            echo "✅ $name: EXECUTED (exit code: $exit_status)"
            ((success_count++))
        else
            # For other phases (preflight), treat non-zero as failure
            if [[ $exit_status -eq 0 ]]; then
                echo "✅ $name: SUCCESS"
                ((success_count++))
            else
                echo "❌ $name: FAILED (exit code: $exit_status)"
            fi
        fi
        echo ""
    done < <(parse_yaml_section "$yaml_file" "$section" | jq -c '.[]')
    echo ""
    
    # Re-enable set -e
    set -e
    
    # Only exit with failure if any commands failed to execute
    # (not if they ran successfully but found issues)
    if [[ $success_count -lt $total_count ]]; then
        echo "$phase_name phase completed: $success_count/$total_count commands succeeded"
        return 1
    else
        echo "$phase_name phase completed: $success_count/$total_count commands succeeded"
        return 0
    fi
}

# MAIN EXECUTION
process_arguments "$@"
validate_arguments
display_configuration 

# Validate YAML configuration
validate_yaml_config "$CONFIG_FILE"

# Ensure artefact folder exists
ARTEFACT_DIR=".gitcheck"
mkdir -p "$ARTEFACT_DIR"

# If --only is set, run only that phase
if [[ "$ONLY_PHASE" == "validate" ]]; then
    echo "Configuration validated successfully."
    exit 0
elif [[ "$ONLY_PHASE" == "preflight" ]]; then
    execute_yaml_section "$CONFIG_FILE" "preflight" "Preflight"
    echo "GitCheck completed!"
    exit 0
elif [[ "$ONLY_PHASE" == "checks" ]]; then
    execute_yaml_section "$CONFIG_FILE" "checks" "Checks"
    echo "GitCheck completed!"
    exit 0
elif [[ "$ONLY_PHASE" == "metrics" ]]; then
    echo "Metrics phase not yet implemented"
    exit 1
else
    # No --only flag: run all phases in order
    execute_yaml_section "$CONFIG_FILE" "preflight" "Preflight"
    execute_yaml_section "$CONFIG_FILE" "checks" "Checks"
    echo "Metrics phase not yet implemented"
    echo "GitCheck completed!"
fi 